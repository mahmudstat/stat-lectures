<style>
#drawingCanvas {
  position: fixed;
  top: 0; left: 0;
  width: 100vw; height: 100vh;
  z-index: 1000;
  touch-action: none;
}
#controlsWrapper {
  position: fixed;
  top: 10px; left: 10px;
  z-index: 1001;
}
#controls {
  display: none;
  flex-direction: column;
  align-items: center;
  background: #b3b3ff;
  padding: 5px;
  border-radius: 10px;
  gap: 5px;
}
#controls input, #controls button, #shapeSelect {
  width: 40px; height: 40px;
}
#toggleControls {
  background: none; border: none; width: 40px; height: 40px; font-size: 20px;
}
#eraserCursor {
  position: fixed; pointer-events: none;
  border: 1px solid red; border-radius: 50%;
  display: none; z-index: 1002;
}
</style>

<div id="controlsWrapper">
  <button id="toggleControls">üé®</button>
  <div id="controls">
    <button id="penTool">üñâ</button>
    <input type="color" id="penColor" value="#339966" />
    <input type="range" id="penSize" min="1" max="20" value="4" />

    <select id="shapeSelect">
      <option value="free">‚úèÔ∏è</option>
      <option value="line">üìè</option>
      <option value="circle">‚ö™</option>
      <option value="rectangle">‚ñ≠</option>
      <option value="pentagon">‚¨†</option>
    </select>

    <button id="eraserTool">ü©π</button>
    <input type="range" id="eraserSize" min="20" max="250" value="60" />

    <button id="undo">‚Ü©Ô∏è</button>
    <button id="clear" type="button">üóëÔ∏è</button>
  </div>
</div>

<div id="eraserCursor"></div>
<canvas id="drawingCanvas"></canvas>

<script>
document.addEventListener("DOMContentLoaded", () => {
  const canvas = document.getElementById('drawingCanvas');
  const ctx = canvas.getContext('2d');
  const eraserCursor = document.getElementById('eraserCursor');

  let drawing = false, erasing = false;
  let lastX = 0, lastY = 0, startX = 0, startY = 0;
  const history = [];
  let shape = 'free';

  const shapeSelect = document.getElementById('shapeSelect');
  shapeSelect.addEventListener('change', () => shape = shapeSelect.value);

  function resize() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
  }
  window.addEventListener('resize', resize);
  resize();

  function pos(e) {
    if (e.touches) e = e.touches[0];
    return { x: e.clientX, y: e.clientY };
  }
  function updateEraser(x,y) {
    const size = Number(eraserSize.value);
    eraserCursor.style.width = size+'px';
    eraserCursor.style.height = size+'px';
    eraserCursor.style.left = x-size/2+'px';
    eraserCursor.style.top = y-size/2+'px';
  }

  function drawShape(x1, y1, x2, y2) {
    ctx.strokeStyle = penColor.value;
    ctx.lineWidth = Number(penSize.value);
    ctx.beginPath();
    switch (shape) {
      case 'line':
        ctx.moveTo(x1, y1);
        ctx.lineTo(x2, y2);
        break;
      case 'circle': {
        const r = Math.hypot(x2 - x1, y2 - y1);
        ctx.arc(x1, y1, r, 0, 2 * Math.PI);
        break;
      }
      case 'rectangle':
        ctx.rect(x1, y1, x2 - x1, y2 - y1);
        break;
      case 'pentagon': {
        const r = Math.hypot(x2 - x1, y2 - y1);
        const angle = (2 * Math.PI) / 5;
        ctx.moveTo(x1 + r * Math.cos(0), y1 + r * Math.sin(0));
        for (let i = 1; i <= 5; i++) {
          ctx.lineTo(x1 + r * Math.cos(i * angle), y1 + r * Math.sin(i * angle));
        }
        break;
      }
    }
    ctx.stroke();
  }

  function start(e) {
    drawing = true;
    const p = pos(e); startX = lastX = p.x; startY = lastY = p.y;
    history.push(ctx.getImageData(0,0,canvas.width,canvas.height));
    if (shape === 'free') draw(e);
  }
  function end(e) {
    if (!drawing) return;
    drawing = false;
    ctx.globalCompositeOperation = 'source-over';
    if (shape !== 'free' && !erasing) {
      const p = pos(e);
      drawShape(startX, startY, p.x, p.y);
    }
  }
  function draw(e) {
    if (!drawing || shape !== 'free') return;
    const p = pos(e);
    const size = erasing ? Number(eraserSize.value) : Number(penSize.value);
    ctx.lineWidth = size;
    ctx.lineCap = 'round';
    ctx.globalCompositeOperation = erasing ? 'destination-out' : 'source-over';
    ctx.strokeStyle = penColor.value;
    if (erasing) updateEraser(p.x,p.y);
    ctx.beginPath();
    ctx.moveTo(lastX,lastY);
    ctx.lineTo(p.x,p.y);
    ctx.stroke();
    lastX=p.x; lastY=p.y;
  }

  canvas.addEventListener('pointerdown', start);
  canvas.addEventListener('pointermove', draw);
  canvas.addEventListener('pointerup', end);
  canvas.addEventListener('pointercancel', end);

  penTool.onclick = () => {
    erasing = false;
    eraserCursor.style.display='none';
    canvas.style.pointerEvents = 'auto';
  };
  eraserTool.onclick = () => {
    erasing = true;
    eraserCursor.style.display='block';
    canvas.style.pointerEvents = 'auto';
  };
  undo.onclick = () => {
    if (history.length) ctx.putImageData(history.pop(),0,0);
  };
  document.getElementById('clear').addEventListener('click', () => {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    history.length = 0;
  });

  toggleControls.onclick = () => {
    const v = controls.style.display==='flex';
    controls.style.display=v?'none':'flex';
    canvas.style.pointerEvents=v?'none':'auto';
    if (erasing&&!v) eraserCursor.style.display='block';
    else eraserCursor.style.display='none';
  };

  canvas.addEventListener('pointerdown', function(e) {
    this.setPointerCapture(e.pointerId);
  });
  canvas.addEventListener('pointerup', function(e) {
    this.releasePointerCapture(e.pointerId);
  });
});
</script>
